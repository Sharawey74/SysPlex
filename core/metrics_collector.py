"""
Metrics Collector Module

Reads and parses system metrics from current.json generated by
the existing PowerShell/Bash monitoring infrastructure.
"""

import json
import logging
from pathlib import Path
from typing import Dict, Any, List, Optional

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Default paths
DEFAULT_METRICS_PATH = "data/metrics/current.json"


def load_current_metrics(path: str = DEFAULT_METRICS_PATH) -> Dict[str, Any]:
    """
    Load system metrics from current.json.
    
    This function reads the JSON file generated by the existing monitoring
    scripts (main_monitor.ps1/.sh) and extracts key metrics for display.
    
    Args:
        path: Path to the current.json file
        
    Returns:
        dict: Parsed metrics with standard structure, or empty dict on error.
              Structure includes:
              - cpu: CPU usage, load average, temperature
              - memory: Used/total memory, usage percentage
              - disk: List of disk metrics per device
              - network: Total RX/TX bytes
              - system: Hostname, platform, uptime
              - temperature: CPU/GPU temperatures if available
              - timestamp: ISO 8601 timestamp of metrics
              
    Example:
        >>> metrics = load_current_metrics()
        >>> cpu_usage = metrics.get('cpu', {}).get('usage_percent', 'N/A')
    """
    metrics_path = Path(path)
    
    try:
        if not metrics_path.exists():
            logger.warning(f"Metrics file not found: {metrics_path}")
            return _get_empty_metrics()
        
        # Use utf-8-sig to handle BOM (Byte Order Mark) from PowerShell scripts
        with metrics_path.open('r', encoding='utf-8-sig') as f:
            raw_data = json.load(f)
        
        # Parse and structure the metrics
        parsed_metrics = _parse_metrics(raw_data)
        logger.debug(f"Successfully loaded metrics from {metrics_path}")
        return parsed_metrics
        
    except json.JSONDecodeError as e:
        logger.error(f"Invalid JSON in {metrics_path}: {e}")
        return _get_empty_metrics()
        
    except PermissionError as e:
        logger.error(f"Permission denied reading {metrics_path}: {e}")
        return _get_empty_metrics()
        
    except Exception as e:
        logger.error(f"Unexpected error reading {metrics_path}: {e}")
        return _get_empty_metrics()


def _parse_metrics(raw_data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Parse raw JSON data into structured metrics.
    
    Args:
        raw_data: Raw JSON data from current.json
        
    Returns:
        dict: Structured metrics dictionary
    """
    # Return raw data as-is since it's already in the correct format from monitoring scripts
    # The PowerShell/Bash scripts already structure the data properly
    return raw_data


def _extract_system_info(system_data: Dict[str, Any]) -> Dict[str, Any]:
    """Extract system information."""
    return {
        'hostname': system_data.get('hostname', 'unknown'),
        'os': system_data.get('os', 'unknown'),
        'uptime': system_data.get('uptime', 'N/A'),
        'manufacturer': system_data.get('manufacturer', 'N/A'),
        'model': system_data.get('model', 'N/A'),
        'status': system_data.get('status', 'unavailable')
    }


def _extract_cpu_metrics(cpu_data: Dict[str, Any]) -> Dict[str, Any]:
    """Extract CPU metrics."""
    if cpu_data.get('status') in ['error', 'unavailable', 'restricted']:
        return {
            'status': cpu_data.get('status', 'unavailable'),
            'usage_percent': None,
            'load_average': None,
            'cores': None,
            'vendor': 'N/A'
        }
    
    # Handle load average (can be dict or list)
    load_avg = cpu_data.get('load_average', {})
    if isinstance(load_avg, dict):
        load_average = [
            load_avg.get('1min', 0.0),
            load_avg.get('5min', 0.0),
            load_avg.get('15min', 0.0)
        ]
    elif isinstance(load_avg, list):
        load_average = load_avg
    else:
        load_average = None
    
    return {
        'status': cpu_data.get('status', 'OK'),
        'usage_percent': cpu_data.get('usage_percent'),
        'load_average': load_average,
        'cores': cpu_data.get('logical_processors') or cpu_data.get('cores'),
        'vendor': cpu_data.get('vendor', 'N/A'),
        'model': cpu_data.get('model', 'N/A')
    }


def _extract_memory_metrics(memory_data: Dict[str, Any]) -> Dict[str, Any]:
    """Extract memory metrics."""
    if memory_data.get('status') in ['error', 'unavailable', 'restricted']:
        return {
            'status': memory_data.get('status', 'unavailable'),
            'used_mb': None,
            'total_mb': None,
            'usage_percent': None
        }
    
    used_mb = memory_data.get('used_mb')
    total_mb = memory_data.get('total_mb')
    usage_percent = memory_data.get('usage_percent')
    
    # Calculate usage percentage if not provided
    if usage_percent is None and used_mb is not None and total_mb is not None and total_mb > 0:
        usage_percent = (used_mb / total_mb) * 100
    
    return {
        'status': memory_data.get('status', 'OK'),
        'used_mb': used_mb,
        'total_mb': total_mb,
        'free_mb': memory_data.get('free_mb'),
        'usage_percent': usage_percent
    }


def _extract_disk_metrics(disk_data: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """Extract disk metrics."""
    if not isinstance(disk_data, list):
        return []
    
    disks = []
    for disk in disk_data:
        # Skip if status indicates unavailable
        if disk.get('status') in ['error', 'unavailable', 'restricted']:
            continue
        
        # Handle both 'usage_percent' and 'used_percent' field names
        usage_percent = disk.get('usage_percent') or disk.get('used_percent')
        
        # Calculate if not provided
        if usage_percent is None:
            used_gb = disk.get('used_gb')
            total_gb = disk.get('total_gb')
            if used_gb is not None and total_gb is not None and total_gb > 0:
                usage_percent = (used_gb / total_gb) * 100
        
        disks.append({
            'device': disk.get('device') or disk.get('mount', 'N/A'),
            'mount': disk.get('mount', 'N/A'),
            'total_gb': disk.get('total_gb'),
            'used_gb': disk.get('used_gb'),
            'free_gb': disk.get('free_gb'),
            'usage_percent': usage_percent,
            'filesystem': disk.get('filesystem', 'N/A')
        })
    
    return disks


def _extract_network_metrics(network_data: List[Dict[str, Any]]) -> Dict[str, Any]:
    """Extract network metrics and calculate totals."""
    if not isinstance(network_data, list):
        return {
            'total_rx_bytes': 0,
            'total_tx_bytes': 0,
            'interfaces': []
        }
    
    total_rx = 0
    total_tx = 0
    interfaces = []
    
    for iface in network_data:
        if iface.get('status') in ['error', 'unavailable', 'restricted']:
            continue
        
        rx_bytes = iface.get('rx_bytes', 0)
        tx_bytes = iface.get('tx_bytes', 0)
        
        # Skip loopback and zero-traffic interfaces for total
        if iface.get('iface', '').lower() not in ['lo', 'loopback']:
            total_rx += rx_bytes
            total_tx += tx_bytes
        
        interfaces.append({
            'iface': iface.get('iface', 'N/A'),
            'rx_bytes': rx_bytes,
            'tx_bytes': tx_bytes
        })
    
    return {
        'total_rx_bytes': total_rx,
        'total_tx_bytes': total_tx,
        'interfaces': interfaces
    }


def _extract_temperature_metrics(temp_data: Dict[str, Any]) -> Dict[str, Any]:
    """Extract temperature metrics with GPU details from new structured format."""
    if temp_data.get('status') in ['error', 'unavailable', 'restricted']:
        return {
            'status': temp_data.get('status', 'unavailable'),
            'cpu_temp': None,
            'gpu_temp': None,
            'cpu_vendor': 'N/A',
            'gpu_vendor': 'N/A',
            'gpu_model': 'N/A',
            'gpu_type': 'N/A',
            'vram_total_mb': 0,
            'vram_used_mb': 0,
            'vram_free_mb': 0,
            'vram_usage_percent': 0,
            'gpu_count': 0,
            'gpus': []
        }
    
    # Extract CPU temperature from cpu object
    cpu_obj = temp_data.get('cpu', {})
    cpu_temp = cpu_obj.get('temperature_celsius', 0) if isinstance(cpu_obj, dict) else temp_data.get('cpu_celsius', 0)
    cpu_vendor = cpu_obj.get('vendor', 'N/A') if isinstance(cpu_obj, dict) else temp_data.get('cpu_vendor', 'N/A')
    
    # Extract GPU data from gpus array (new format) or fallback to old flat format
    gpus = temp_data.get('gpus', [])
    gpu_count = temp_data.get('gpu_count', len(gpus))
    
    # For backward compatibility with old flat format
    if not gpus and temp_data.get('gpu_celsius'):
        gpus = [{
            'vendor': temp_data.get('gpu_vendor', 'N/A'),
            'model': temp_data.get('gpu_model', 'N/A'),
            'type': temp_data.get('gpu_type', 'N/A'),
            'temperature_celsius': temp_data.get('gpu_celsius'),
            'vram_total_mb': temp_data.get('vram_total_mb', 0),
            'vram_used_mb': temp_data.get('vram_used_mb', 0),
            'vram_free_mb': temp_data.get('vram_free_mb', 0),
            'index': 0
        }]
        gpu_count = 1
    
    # Extract primary GPU info for backward compatibility fields
    primary_gpu = None
    if gpus:
        # Prefer dedicated GPU
        for gpu in gpus:
            if gpu.get('type') == 'Dedicated':
                primary_gpu = gpu
                break
        if not primary_gpu:
            primary_gpu = gpus[0]
    
    # Calculate VRAM usage for primary GPU
    vram_total = primary_gpu.get('vram_total_mb', 0) if primary_gpu else 0
    vram_used = primary_gpu.get('vram_used_mb', 0) if primary_gpu else 0
    vram_free = primary_gpu.get('vram_free_mb', 0) if primary_gpu else 0
    vram_usage_percent = 0
    
    if vram_total > 0 and vram_used > 0:
        vram_usage_percent = round((vram_used / vram_total) * 100, 1)
    
    return {
        'status': temp_data.get('status', 'ok'),
        # CPU data
        'cpu_temp': cpu_temp if cpu_temp > 0 else None,
        'cpu_vendor': cpu_vendor,
        # Primary GPU data (for backward compatibility)
        'gpu_temp': primary_gpu.get('temperature_celsius') if primary_gpu else None,
        'gpu_vendor': primary_gpu.get('vendor', 'N/A') if primary_gpu else 'N/A',
        'gpu_model': primary_gpu.get('model', 'N/A') if primary_gpu else 'N/A',
        'gpu_type': primary_gpu.get('type', 'N/A') if primary_gpu else 'N/A',
        'vram_total_mb': vram_total,
        'vram_used_mb': vram_used,
        'vram_free_mb': vram_free,
        'vram_usage_percent': vram_usage_percent,
        # New structured format
        'gpu_count': gpu_count,
        'gpus': gpus
    }


def _extract_fan_metrics(fan_data: Dict[str, Any]) -> Dict[str, Any]:
    """Extract fan metrics."""
    if fan_data.get('status') in ['error', 'unavailable', 'restricted']:
        return {
            'status': fan_data.get('status', 'unavailable'),
            'fans': []
        }
    
    # Handle both list and single fan object
    fans = []
    if isinstance(fan_data.get('fans'), list):
        fans = fan_data.get('fans', [])
    elif 'rpm' in fan_data:
        fans = [{'name': 'System Fan', 'rpm': fan_data.get('rpm')}]
    
    return {
        'status': fan_data.get('status', 'OK'),
        'fans': fans
    }


def _get_empty_metrics() -> Dict[str, Any]:
    """
    Return empty metrics structure with default values.
    
    Returns:
        dict: Empty metrics with N/A values
    """
    return {
        'timestamp': 'N/A',
        'platform': 'unknown',
        'system': {
            'hostname': 'unknown',
            'os': 'unknown',
            'uptime': 'N/A',
            'manufacturer': 'N/A',
            'model': 'N/A',
            'status': 'unavailable'
        },
        'cpu': {
            'status': 'unavailable',
            'usage_percent': None,
            'load_average': None,
            'cores': None,
            'vendor': 'N/A'
        },
        'memory': {
            'status': 'unavailable',
            'used_mb': None,
            'total_mb': None,
            'usage_percent': None
        },
        'disk': [],
        'network': {
            'total_rx_bytes': 0,
            'total_tx_bytes': 0,
            'interfaces': []
        },
        'temperature': {
            'status': 'unavailable',
            'cpu_temp': None,
            'gpu_temp': None
        },
        'fans': {
            'status': 'unavailable',
            'fans': []
        }
    }


def get_metric_value(metrics: Dict[str, Any], path: str, default: Any = 'N/A') -> Any:
    """
    Safely get a nested metric value using dot notation.
    
    Args:
        metrics: Metrics dictionary
        path: Dot-separated path (e.g., 'cpu.usage_percent')
        default: Default value if path not found
        
    Returns:
        The metric value or default
        
    Example:
        >>> cpu_usage = get_metric_value(metrics, 'cpu.usage_percent', 0)
    """
    keys = path.split('.')
    value = metrics
    
    for key in keys:
        if isinstance(value, dict):
            value = value.get(key)
            if value is None:
                return default
        else:
            return default
    
    return value if value is not None else default
